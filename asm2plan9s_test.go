package asm2plan9s

import (
	"bytes"
	"testing"
)

func TestInstruction(t *testing.T) {

	for n, tst := range []struct {
		testName, sigil string
		ins, out        string
		err             error
	}{
		{testName: "Add byte codes",
			sigil: "// @",
			ins:   "                                 // @ VPADDQ  XMM0,XMM1,XMM8",
			out:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  XMM0,XMM1,XMM8\n",
			err:   nil,
		},
		{testName: "Correct byte codes",
			sigil: "// @",
			ins:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  XMM0,XMM1,XMM8",
			out:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  XMM0,XMM1,XMM8\n",
			err:   nil,
		},
		{testName: "Incorrect byte codes",
			sigil: "// @",
			ins:   "    LONG $0x003377BB; BYTE $0xFF // @ VPADDQ  XMM0,XMM1,XMM8",
			out:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  XMM0,XMM1,XMM8\n",
			err:   nil,
		},
		{testName: "In-macro codes",
			sigil: "// @",
			ins:   "    LONG $0x00000000; BYTE $0xDD                               \\ // @ VPADDQ  XMM0,XMM1,XMM8",
			out:   "    LONG $0xD471C1C4; BYTE $0xC0 \\ // @ VPADDQ  XMM0,XMM1,XMM8\n",
			err:   nil,
		},
		{testName: "Insert byte codes",
			sigil: "// @",
			ins:   "                                   // @ VPALIGNR XMM8, XMM12, XMM12, 0x8",
			out:   "    LONG $0x0F1943C4; WORD $0x08C4 // @ VPALIGNR XMM8, XMM12, XMM12, 0x8\n",
			err:   nil,
		},
		{testName: "Multiple lines",
			sigil: "// @",
			ins:   `                                   // @ VPALIGNR XMM8, XMM12, XMM12, 0x8`,
			out:   "    LONG $0x0F1943C4; WORD $0x08C4 // @ VPALIGNR XMM8, XMM12, XMM12, 0x8\n",
			err:   nil,
		},
		{testName: "Plan9 instr",
			sigil: "// @",
			ins:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  X1, X8, X0",
			out:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VPADDQ  X1, X8, X0\n",
			err:   nil,
		},
		{testName: "Plan9 avx instr const",
			sigil: "// @",
			ins:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ VSHUFPD $1, X1, X8, X0",
			out:   "    LONG $0xC671C1C4; WORD $0x01C0 // @ VSHUFPD $1, X1, X8, X0\n",
			err:   nil,
		},
		{testName: "Intl instr const",
			sigil: "// @",
			ins:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ SHUFPD XMM0, XMM1, 0X3",
			out:   "    LONG $0xC1C60F66; BYTE $0x03 // @ SHUFPD XMM0, XMM1, 0X3\n",
			err:   nil,
		},
		{testName: "Plan9 instr const",
			sigil: "// @",
			ins:   "    LONG $0xD471C1C4; BYTE $0xC0 // @ SHUFPD $3, X1, X0",
			out:   "    LONG $0xC1C60F66; BYTE $0x03 // @ SHUFPD $3, X1, X0\n",
			err:   nil,
		},
		{testName: "Macro start",
			sigil: "// @",
			ins:   " #define macro   LONG $0xD471C1C4; BYTE $0xC0 \\ // @ SHUFPD $3, X1, X0",
			out:   "#define macro    LONG $0xC1C60F66; BYTE $0x03 \\ // @ SHUFPD $3, X1, X0\n",
			err:   nil,
		},
		{testName: "Intel addressing",
			sigil: "// @",
			ins:   "     // @ VFMADD132PD xmm1, xmm0, [rax]",
			out:   "    LONG $0x98F9E2C4; BYTE $0x08 // @ VFMADD132PD xmm1, xmm0, [rax]\n",
			err:   nil,
		},
		{testName: "GoAsm addressing",
			sigil: "// @",
			ins:   "     // @ VFMADD132PD X0, (AX), X1",
			out:   "    LONG $0x98F9E2C4; BYTE $0x08 // @ VFMADD132PD X0, (AX), X1\n",
			err:   nil,
		},
		{testName: "Go register in instr",
			sigil: "// @",
			ins:   "     // @ ADDSUBPD X0, X1",
			out:   "    LONG $0xC8D00F66 // @ ADDSUBPD X0, X1\n",
			err:   nil,
		},
		{testName: "Go 2-register calculation",
			sigil: "// @",
			ins:   "     // @ ADDSUBPD (AX)(BX*4), X0",
			out:   "    LONG $0x04D00F66; BYTE $0x98 // @ ADDSUBPD (AX)(BX*4), X0\n",
			err:   nil,
		},
		{testName: "Go 2-register calculation with offset",
			sigil: "// @",
			ins:   "     // @ ADDSUBPD 16(AX)(BX*4), X0",
			out:   "    LONG $0x44D00F66; WORD $0x1098 // @ ADDSUBPD 16(AX)(BX*4), X0\n",
			err:   nil,
		},
		{testName: "LONG + WORD + BYTE output",
			sigil: "// @",
			ins:   "     // @ MOVDDUP 16(AX)(BX*4), X9",
			out:   "    LONG $0x120F44F2; WORD $0x984C; BYTE $0x10 // @ MOVDDUP 16(AX)(BX*4), X9\n",
			err:   nil,
		},
		{testName: "Comment /*",
			sigil: "// @",
			ins:   "     // @ MOVDDUP 16(AX)(BX*4), X9 /* ADDPS X0,X0 */",
			out:   "    LONG $0x120F44F2; WORD $0x984C; BYTE $0x10 // @ MOVDDUP 16(AX)(BX*4), X9 /* ADDPS X0,X0 */\n",
			err:   nil,
		},
		{testName: "Comment //",
			sigil: "// @",
			ins:   "     // @ MOVDDUP 16(AX)(BX*4), X9 // ADDPS X0,X0",
			out:   "    LONG $0x120F44F2; WORD $0x984C; BYTE $0x10 // @ MOVDDUP 16(AX)(BX*4), X9 // ADDPS X0,X0\n",
			err:   nil,
		},
	} {
		inBuf := bytes.NewReader([]byte(tst.ins))

		result, err := Assemble(tst.sigil, inBuf)
		if err != tst.err {
			t.Error(err)
			continue
		}
		if string(result) != tst.out {
			t.Errorf("Test %d (%s) expected \n%s\ngot\n%s", n, tst.testName, tst.out, result)
		}
	}
}
